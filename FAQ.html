<html>

  <head>
    <title>Untitled</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://unpkg.com/@stencila/thema@1/dist/themes/stencila/styles.css"
      rel="stylesheet">
    <script src="https://unpkg.com/@stencila/thema@1/dist/themes/stencila/index.js"
      type="text/javascript"></script>
    <script
      src="https://unpkg.com/@stencila/components@&lt;=1/dist/stencila-components/stencila-components.esm.js"
      type="module"></script>
    <script
      src="https://unpkg.com/@stencila/components@&lt;=1/dist/stencila-components/stencila-components.js"
      type="text/javascript"></script>
  </head>

  <body>
    <article itemtype="https://schema.org/Article" itemscope="true">
      <h1 itemprop="headline">Untitled</h1>
      <h1 id="faq">FAQ</h1>
      <h2 id="developmenttechnical-questions">Development/Technical Questions</h2>
      <h2
        id="why-do-all-the-codecs-both--and--codec-shouldn39t-just-extending-accomplish-the-method-checking">
        Why do all the codecs both <code>extend</code> and <code>implement</code> Codec?
        Shouldn&#39;t just extending accomplish the method checking?</h2>
      <p>One of the primary reasons for using classes was to improve the type safety of the Codecs
        and ensure they all conform to the required interfaces.</p>
      <p>Due to the nature of how the implementation of properties are enforced in TypeScript, and
        the ability to check class inheritance at runtime, we use both the <code>extend</code> and
        <code>implement</code> keywords.</p>
      <p>Below is an example demonstrating the shortcomings of each <code>keyword</code> when used
        by itself.</p>
      <h3 id="only-using">Only using <code>extends</code></h3>
      <pre><code class="language-ts">class A {
  public mediaTypes: string[]
  public extNames?: string[]
  public encode: (n: Node) =&gt; Promise&lt;VFile&gt;
}

class B extends A {
  // ğŸ‘ no TypeScript errors reported as all fields are inherited
}

B.prototype instanceof A // true
// ğŸ‘ Class inheritance can be validated at runtime</code></pre>
      <pre><code class="language-ts">abstract class A {
  public abstract mediaTypes: string[]
  public abstract extNames?: string[]
  public abstract encode: (n: Node) =&gt; Promise&lt;VFile&gt;
}

class B extends A {
  // ğŸ‘ TypeScript errors reported for all necessary fields
}

B.prototype instanceof A // false
// ğŸ‘ Class inheritance cannot be validated at runtime
// This is necessary to dynamically import and instantiate a codec at runtime</code></pre>
      <pre><code class="language-ts">abstract class A {
  public abstract mediaTypes: string[]
  public extNames?: string[]
  // âš ï¸ Optional methods/properties are not marked as `abstract`, otherwise TypeScript
  // raises a false error requiring the user to implement it

  public abstract encode: (n: Node) =&gt; Promise&lt;VFile&gt;
}

class B extends A {
  // ğŸ‘ no TypeScript errors reported as all fields are inherited
}

B.prototype instanceof A // true
// ğŸ‘ Class inheritance can be validated at runtime</code></pre>
    </article>
  </body>

</html>