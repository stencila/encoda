import { schema } from '@stencila/jesta'
import { MathMLCodec, normalize } from '.'
import {
  asciimathBlock,
  asciimathFragment,
  mathmlBlock,
  mathmlBlockString,
  mathmlFragment,
  mathmlInlineString,
  mathmlString,
  texBlock,
  texFragment,
  texString,
} from '../../__fixtures__/math/kitchen-sink'

const mathml = new MathMLCodec()

describe('sniff', () => {
  const sniff = mathml.sniff

  test('success', async () => {
    expect(await sniff('<math>')).toBe(true)
    expect(await sniff(' <math')).toBe(true)
    expect(await sniff('\n <math></math>')).toBe(true)
  })

  test('success', async () => {
    expect(await sniff('foo <math')).toBe(false)
    expect(await sniff(__dirname)).toBe(false)
    expect(await sniff(__filename)).toBe(false)
  })
})

describe('normalize', () => {
  it('replaces deprecated constants with values', () => {
    expect(
      normalize(`
<mml:mspace width="veryverythinmathspace"/>
<mml:mspace width="verythinmathspace"/>
<mml:mspace width="thinmathspace"/>
<mml:mspace width="mediummathspace"/>
<mml:mspace width="thickmathspace"/>
<mml:mspace width="verythickmathspace"/>
<mml:mspace width="veryverythickmathspace"/>

<mml:mspace width="negativeveryverythinmathspace"/>
<mml:mspace width="negativeverythinmathspace"/>
<mml:mspace width="negativethinmathspace"/>
<mml:mspace width="negativemediummathspace"/>
<mml:mspace width="negativethickmathspace"/>
<mml:mspace width="negativeverythickmathspace"/>
<mml:mspace width="negativeveryverythickmathspace"/>
`)
    ).toBe(`
<mml:mspace width="0.0555em"/>
<mml:mspace width="0.1111em"/>
<mml:mspace width="0.1667em"/>
<mml:mspace width="0.2222em"/>
<mml:mspace width="0.2778em"/>
<mml:mspace width="0.3333em"/>
<mml:mspace width="0.3889em"/>

<mml:mspace width="-0.0555em"/>
<mml:mspace width="-0.1111em"/>
<mml:mspace width="-0.1667em"/>
<mml:mspace width="-0.2222em"/>
<mml:mspace width="-0.2778em"/>
<mml:mspace width="-0.3333em"/>
<mml:mspace width="-0.3889em]"/>
`)
  })
})

describe('decode', () => {
  const decode = (content: string) => mathml.load(content)

  test('success', async () => {
    expect(await decode(mathmlString)).toEqual(
      schema.mathFragment({ mathLanguage: 'mathml', text: mathmlString })
    )
    expect(await decode(mathmlInlineString)).toEqual(
      schema.mathFragment({ mathLanguage: 'mathml', text: mathmlInlineString })
    )
    expect(await decode(mathmlBlockString)).toEqual(
      schema.mathBlock({ mathLanguage: 'mathml', text: mathmlBlockString })
    )
  })

  test('failure', async () => {
    expect(await decode('')).toEqual(
      schema.mathFragment({ mathLanguage: 'mathml', text: '' })
    )
  })
})

describe('encode', () => {
  const encode = (node: schema.Math) => mathml.dump(node)

  test('success', async () => {
    expect(await encode(mathmlFragment)).toEqual(mathmlString)
    expect(await encode(mathmlBlock)).toEqual(mathmlString)

    // The MathML generated by MathJax for these test fixtures
    // should match this regex
    const mml = /<mi>E<\/mi>/

    expect(await encode(asciimathFragment)).toMatch(mml)
    expect(await encode(asciimathBlock)).toMatch(mml)

    expect(await encode(texFragment)).toMatch(mml)
    expect(await encode(texBlock)).toMatch(mml)

    // No `mathLanguage`, assumed to be `tex`
    expect(await encode(schema.mathFragment({ text: texString }))).toMatch(mml)
  })

  test('failure', async () => {
    expect(
      await encode(
        // @ts-ignore
        schema.article()
      )
    ).toMatch('')

    expect(
      await encode(schema.mathFragment({ mathLanguage: 'foo', text: '' }))
    ).toMatch('')
  })
})
